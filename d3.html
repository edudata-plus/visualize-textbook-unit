<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>教科書関係可視化</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    #graph {
      width: 100%;
      height: 600px;
      border: 1px solid #ccc;
    }
    #lod-input {
      margin-top: 10px;
      display: flex;
      align-items: center;
    }
    #lod-input label {
      margin-right: 10px;
    }
    #lod-input .clear {

    }
    #lod-uri {
      flex-grow: 1;
      padding: 5px;
    }
    .browse-list {
      float: left;
      margin-right: 15px;
    }
    .browse-list h1 {
      font-size: medium;
    }
  </style>
</head>
<body>
  <svg id="graph"></svg>
  <div id="lod-input">
    <!--
    <label for="lod-uri">教科書LOD URI:</label>
    <input type="text" id="lod-uri" placeholder="LODのURIを入力">
    <button onclick="fetchSPARQLData()">読み込み</button>
    -->
    <ul id="lod-loaded">
    </ul>
    <button class="clear" onclick="reset()">リセット</button>
  </div>
  <nav class="browse-list">
    <h1>学校種別</h1>
    <ul>
      <li><a href="javascript:fetchSubjectData('https://w3id.org/jp-textbook/curriculum/小学校/2020')">小学校</a></li>
      <li><a href="javascript:fetchSubjectData('https://w3id.org/jp-textbook/curriculum/中学校/2021')">中学校</a></li>
      <li><a href="javascript:fetchSubjectData('https://w3id.org/jp-textbook/curriculum/高等学校/2022')">高等学校</a></li>
    </ul>
  </nav>
  <nav class="browse-list" style="visibility: hidden">
    <h1>種目一覧</h1>
    <ul id="subject-list">
    </ul>
  </nav>
  <nav class="browse-list" style="visibility: hidden;">
    <h1>教科書一覧</h1>
    <ul id="textbook-list">
    </ul>
  </nav>
  <script>
    function load_textbook(uri) {
      let input = document.getElementById("lod-uri");
      input.value = uri;
    }
    async function fetchTextbookData(uri) {
      if (!uri) {
        alert("Subject URI not found");
        return;
      }
      const endpoint = "https://dydra.com/masao/jp-textbook/sparql";
      const query = `PREFIX t: <https://w3id.org/jp-textbook/>
                     PREFIX schema: <http://schema.org/>
                     PREFIX dct: <http://purl.org/dc/terms/>
                     select * where {
                     ?textbook a t:Textbook.
                     ?textbook t:subject <${uri}>.
                     ?textbook schema:name ?name.
                     ?textbook dct:bibliographicCitation ?bib.
                     } order by ?textbook`;
      const url = endpoint + "?query=" + encodeURIComponent(query) + "&format=json";
      try {
        const response = await fetch(url, { headers: { "Accept": "application/sparql-results+json" } });
        const data = await response.json();
        let list = document.getElementById("textbook-list");
        list.parentElement.style.visibility = "visible";
        list.innerHTML = "";
        for (const row of data.results.bindings) {
          list.innerHTML += `<li><a href="javascript:load_textbook('${row.textbook.value}')">${row.bib.value}</a>  <a href="javascript:load_textbook('${row.textbook.value}', false)" title="現在の描画に追加する">＋</a>  <a href="${row.textbook.value}" target="_blank"><img src="https://www.w3.org/RDF/icons/rdf_flyer.24" title="LOD" alt="LOD"></a></li>`;
        }
      } catch (error) {
        console.error("教科書データの取得に失敗しました:", error);
        alert("教科書データの取得に失敗しました。");
      }

    }
    async function fetchSubjectData(uri) {
      if (!uri) {
        alert("Subject URI not found");
        return;
      }
      const endpoint = "https://dydra.com/masao/jp-textbook/sparql";
      const query = `PREFIX t: <https://w3id.org/jp-textbook/>
                     PREFIX schema: <http://schema.org/>
                     select * where {
                     <${uri}> t:hasSubjectArea ?area.
                     ?area t:hasSubject ?subject.
                     ?subject schema:name ?subject_label.
                     ?subject <http://purl.org/linked-data/cube#order> ?order.
                     FILTER (lang(?subject_label) = 'ja')
                     } order by ?order`;
      const url = endpoint + "?query=" + encodeURIComponent(query) + "&format=json";
      try {
        const response = await fetch(url, { headers: { "Accept": "application/sparql-results+json" } });
        const data = await response.json();
        //let subjects = [];
        let subject = document.getElementById("subject-list");
        subject.parentElement.style.visibility = "visible";
        subject.innerHTML = "";
        for (const row of data.results.bindings) {
          subject.innerHTML += `<li><a href="javascript:fetchTextbookData('${row.subject.value}')">${row.subject_label.value}</li>`;
        }
      } catch (error) {
        console.error("種目データの取得に失敗しました:", error);
        alert("種目データの取得に失敗しました。");
      }
    };
  </script>
  <script>
    async function load_textbook(uri, clear = true) {
      const endpoint = "https://dydra.com/masao/jp-textbook/sparql";
      const query = `PREFIX t: <https://w3id.org/jp-textbook/>
                     PREFIX schema: <http://schema.org/>
                     SELECT ?unit ?name ?item ?title WHERE {
                       ?unit a t:TeachingUnit.
                       ?unit schema:workExample ?w.
                       ?w schema:isPartOf <${uri}>.
                       <${uri}> schema:name ?title.
                       ?unit schema:name ?name.
                       ?unit <https://w3id.org/jp-cos/cosItem> ?item.
                     }`;
      
      const url = endpoint + "?query=" + encodeURIComponent(query) + "&format=json";
      try {
        const response = await fetch(url, { headers: { "Accept": "application/sparql-results+json" } });
        const data = await response.json();
        
        let nodes = [], links = [];
        let textbookNode = { id: uri, label: data.results.bindings[0].title.value, group: "textbook" };
        nodes.push(textbookNode);
        
        for (const row of data.results.bindings) {
          if (!nodes.find(n => n.id === row.unit.value)) {
            nodes.push({ id: row.unit.value, label: row.name.value, group: "unit" });
          }
          links.push({ source: textbookNode.id, target: row.unit.value });
          
          if (!nodes.find(n => n.id === row.item.value)) {
            let itemLabel = row.item.value.slice(-16); // URIの末尾16桁をラベルとして使用
            nodes.push({ id: row.item.value, label: itemLabel, group: "detail" });
          }
          links.push({ source: row.unit.value, target: row.item.value });
        }
        renderGraph(nodes, links, clear);
      } catch (error) {
        console.error("データの取得に失敗しました:", error);
        alert("データの取得に失敗しました。");
      }
    }

    function reset() {
      const svg = d3.select("#graph");
      svg.selectAll("*").remove();
      d3.select("#tooltip").remove();
      if (window.simulation) {
        window.simulation.stop();  // シミュレーション停止
        window.simulation.nodes([]); // ノードデータを空に
        window.simulation.force("link").links([]); // リンクデータも空に
      }
    }

    function renderGraph(newNodes, newLinks, clear = true) {
      const width = 800, height = 600;
  
      // 既存のデータ取得
      let svg = d3.select("#graph");
      if (svg.empty()) {
        svg = d3.select("body").append("svg")
          .attr("id", "graph")
          .attr("width", width)
          .attr("height", height);
      }
      if (clear) {
        reset();
      }

      // ツールチップ用のdivを確保（なければ作成）
      let tooltip = d3.select("#tooltip");
      if (tooltip.empty()) {
        tooltip = d3.select("body").append("div")
          .attr("id", "tooltip")
          .style("position", "absolute")
          .style("visibility", "hidden")
          .style("background", "lightgray")
          .style("padding", "5px")
          .style("border-radius", "5px")
          .style("font-size", "12px");
      }

      // シミュレーションのグローバル変数を確保
      if (!window.simulation) {
        window.simulation = d3.forceSimulation()
          .force("link", d3.forceLink().id(d => d.id).distance(100))
          .force("charge", d3.forceManyBody().strength(-300))
          .force("center", d3.forceCenter(width / 2, height / 2))
          .force("x", d3.forceX(width / 2).strength(0.1))
          .force("y", d3.forceY(height / 2).strength(0.1));
      }
      const simulation = window.simulation;

      // すでに描画済みのデータを取得
      let existingNodes = simulation.nodes();
      let existingLinks = simulation.force("link").links();

      // 既存のノードIDをセットに
      const existingNodeIds = new Set(existingNodes.map(n => n.id));

      // 既存のリンク(ソース, ターゲット)ペアをセットに
      const existingLinkPairs = new Set(existingLinks.map(l => JSON.stringify([l.source.id, l.target.id])));

      // 重複しない新規ノードを追加
      newNodes = newNodes.filter(n => !existingNodeIds.has(n.id));
      const updatedNodes = [...existingNodes, ...newNodes];

      // 重複しない新規リンクを追加
      newLinks = newLinks.filter(l => !existingLinkPairs.has(JSON.stringify([l.source, l.target])));
      const updatedLinks = [...existingLinks, ...newLinks];

      // リンクの描画・更新
      const link = svg.selectAll(".link")
        .data(updatedLinks, d => d.source.id + "-" + d.target.id);

      link.enter().append("line")
        .attr("class", "link")
        .attr("stroke", "#999")
        .attr("stroke-width", 2)
        .merge(link);

      link.exit().remove();

      // ノードの描画・更新
      const node = svg.selectAll(".node")
        .data(updatedNodes, d => d.id);

      const nodeEnter = node.enter().append("circle")
        .attr("class", "node")
        .attr("r", 10)
        .attr("fill", d => d.group === "textbook" ? "blue" : d.group === "unit" ? "green" : "red")
        .call(d3.drag()
          .on("start", dragstarted)
          .on("drag", dragged)
          .on("end", dragended));

      // ツールチップイベントを追加
      nodeEnter.on("mouseover", function (event, d) {
        tooltip.style("visibility", "visible").text(d.label);
      })
      .on("mousemove", function (event) {
        tooltip.style("top", (event.pageY + 10) + "px")
          .style("left", (event.pageX + 10) + "px");
      })
      .on("mouseout", function () {
        tooltip.style("visibility", "hidden");
      });

      nodeEnter.merge(node);
      node.exit().remove();

      // ラベルの描画・更新
      const label = svg.selectAll(".label")
        .data(updatedNodes, d => d.id);

      const labelEnter = label.enter()
        .append("a")
        .attr("xlink:href", d => d.id)
        .attr("target", "_blank")
        .append("text")
        .attr("class", "label")
        .attr("dy", -10)
        .attr("text-anchor", "middle")
        .attr("font-size", "10px")
        .text(d => d.label);
      labelEnter.merge(label);
      label.exit().remove();

      // シミュレーション更新
      simulation.nodes(updatedNodes);
      simulation.force("link").links(updatedLinks);
      simulation.alpha(1).restart();

      simulation.on("tick", () => {
        svg.selectAll(".link")
          .attr("x1", d => d.source.x)
          .attr("y1", d => d.source.y)
          .attr("x2", d => d.target.x)
          .attr("y2", d => d.target.y);

        svg.selectAll(".node")
          .attr("cx", d => d.x)
          .attr("cy", d => d.y);

        svg.selectAll(".label")
          .attr("x", d => d.x)
          .attr("y", d => d.y);
      });

      function dragstarted(event, d) {
        if (!event.active) simulation.alphaTarget(0.3).restart();
        d.fx = d.x;
        d.fy = d.y;
      }
      function dragged(event, d) {
        d.fx = event.x;
        d.fy = event.y;
      }
      function dragended(event, d) {
        if (!event.active) simulation.alphaTarget(0);
        d.fx = null;
        d.fy = null;
      }
    }
  </script>
</body>
</html>